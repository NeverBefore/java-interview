##### 1.JVM运行内存的分类
        程序计数器(Program Counter Register)
            也被称作PC寄存器，当前线程所执行的字节码的行号指示器，也可以说保存下一条指令所在的存储单元的地址
        Java栈
            也被称作虚拟机栈(Java Vitual Machine Stack),存储方法中的局部变量，包括在方法中声明的非静态变量和函数形参
            存放基本数据类型，对象的引用和方法出口
        本地方法栈
            和虚拟栈相似，只不过它服务于本地方法 (native method)
        堆
            是内存中最大的一块，所有对象实例、数组都存放在堆里
            堆是Java垃圾收集器管理(GC)的主要管理区域
            对是被所有线程共享的，在jvm中只有一个堆
        方法区
            存储每个类的信息，包括类的名称、方法信息、字段信息，静态常量，常量，以及编译器编译后的代码
            在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，
            在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，
            在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。
            
##### 2.堆和栈的区别
        最通俗的一点就是：堆是用来存放对象的，栈是用来存放执行程序的
        应用程序所有的部分都使用堆内存，然后栈内存通过一个线程运行来使用。
        不论对象什么时候创建，他都会存储在堆内存中，栈内存包含它的引用。栈内存只包含本地原始变量和堆中对象变量的引用。
        存储在堆中的对象是全局可以被访问的，然而栈内存不能被其他线程所访问。
        栈内存是生命周期很短的，然而堆内存的生命周期从程序的运行开始到运行结束。
        和堆内存比，栈内存要小的多，因为明确使用了内存分配规则（LIFO），和堆内存相比栈内存非常快。
##### 3.GC回收机制
        GC：Garbage Collection 垃圾收集
            所谓的垃圾是指在系统运行过程中产生的一些无用的对象，这些对象占据着一定的内存空间，如果长期不释放，可能会OOM(Out Of Memory)
        GC需要完成的三件事情：
            1.哪些内存需要回收
                在堆中没有引用，不会再次被使用的对象是需要回收的，那如何判断对象是否失效呢？
                    1.1 引用计数法
                        原理：给对象添加一个引用计数器，这个对象被使用的时候计数器+1，失效的时候计数器-1。当该对象引用为0的时候，
                        判定对象失效，可以被GC回收了
                            优点：实现简单，判定效率高
                            缺点：A->B,B->A,那么 AB 将永远不会被回收了。很难解决对象之间循环引用的问题
                    1.2 可达性分析法(根搜索算法)
                        原理：通过一个叫GC Roots的对象作为起点，从这些节点开始向下搜索，搜索走过的路径被称为引用链，当一个对象
                        没有与任何的引用链相连，那么这个对象就可以被GC回收了
                        Java中可作为GC Roots的对象
                            虚拟机栈（栈帧中的本地变量表）中引用的对象；
                            方法区中类静态属性引用的对象；
                            方法区中常量引用的对象；
                            本地方法栈中JNI（即一般说的Native方法）引用的对象。
            2.什么时候回收
                当jvm分析出失效的对象的时候，并不是马上清除，而是进行标记并判断是否回收
                    2.1 判断对象是否覆盖了finalize()方法
                        如果覆盖，那么将finalize()方法放到F-Queue队列中
                        如果没有覆盖，直接回收
                    2.2 执行F-Queue队列中的finalize()方法
                        虚拟机会自动创建一个优先级较低的线程去执行F-Queue中的finalize()方法，这里的执行只是触发这些方法并不会
                        保证会等待它执行完毕。如果finalize()方法作了耗时操作，虚拟机会停止执行并清除该对象
                    2.3 对象销毁或重生
                        在finalize()方法中，将this赋值给某一个引用，那么该对象就重生了。如果没有引用则被回收
            3.如何回收      
                GC回收算法
                    3.1 标记-清楚法分为两个阶段：
                        3.1.1 标记阶段：首先遍历所有GC Roots对象，对从GC Roots对象可达的对象都做一个可达标记。这个可达标识一般记录
                        在对象头中，表示该对象可以被GC Roots访问
                        3.1.2 清除阶段：对堆内存进行遍历，通过读取对象头的信息来获取对象是否标记可达。没有标记就被回收
                        缺点：效率问题，空间碎片太多会导致大内存对象无法生成而频繁进行 GC。
                    3.2 复制算法
                        原理：按照容量划分两个大小相等的区域，当一块用完的时候将活着的对象复制到另一块上然后再把已经使用的内存
                        空间一次清理掉。
                        缺点：将内存分为一半，代价高
                    3.3 标记-整理法
                        标记过程与标记-清除的标记算法相同，但后续不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，
                        然后直接清理掉端边界以外的内存
                        优点：解决了标记- 清除算法导致的内存碎片问题，内存规整
                        缺点：效率不如复制算法
                三种算法排行
                    效率:复制算法>标记-整理>标记-清除
                    内存规整率：标记-整理=复制>标记清除
                    内存利用率：标记-整理=标记辅助>复制
                    3.4 分代收集算法
                        把Java堆分为新生代和老年代，新生代基本采用复制算法，老年代采用标记-整理算法

        
            