##### 1.解释内存中的栈（stack），堆（heap），和方法区（method area）的用法。

	通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用JVM中的栈空间；而通过new关键字和构造器创建的对象则是放在堆空间里，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老年代，再具体一点就是分为Eden，Survivor（又可以分为From Survivor和To Survivor），Tenured；方法区和堆都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息，常量和静态变量，JIT编译器编译后的代码等数据；程序中的字面量如直接书写的100，"hello"都是放在常量池中，常量池是方法区的一部分。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆里面，栈和堆的大小都可以通过JVM的启动参数来进行调整，栈空间用光了会引发StackOverflowError，而堆和常量池空间不足则会引发OutOfMemoryError。
	String str = new String("hello");
	上面的语句中，str放在栈上面，而new出来的字符串对象放在堆上，而"hello"这个字面量是放在方法区里面的。

##### 2.Java对于equals方法和hashcode方法的规定
	如果两个对象的equals方法返回true，那么这两个对象一定相同
	如果两个对象的hashcode相同，那么这两个对象不一定相同

##### 3.String和StringBuilder，StringBuffer的区别？
	String只读字符串，也就意味着String引用的字符串不能改变。
	StringBuilder和StringBuffer表示的字符串可以修改，它们两个的用法相同，区别在于StringBuilder是在单线程的环境下使用，因为它没有加synchroniezd锁，所以StringBuiler比StringBuffer的效率要高。

##### 4.JVM加载class文件的原理机制
	JVM中类的加载是由类加载器和它的子类实现的，类加载器是一个重要的Java运行组件，它负责在运行时查找和装入类文件的类。
		当Java程序要使用某个类时，JVM会确保这个类以及被加载，连接（验证，准备和解析）和初始化。
		类的加载是指把class文件读入内存中。通常是一个字节数组读入.class文件，然后产生与所加载的类对应的Class对象。
		加载完成后，Class对象还不完整，所以这个类还不能用。
		当类被加载后就进入连接阶段了，这一阶段包括验证，准备和解析。
		最后JVM进行初始化,包括：1).如果类存在直接的父类并且这个类还没有被初始化那么就会先初始化父类，2).如果类中存在初始化语句，就依次执行这些初始化语句

##### 5.抽象类和接口有什么异同
		抽象类和接口都不能被实例化，但是可以定义抽象类和接口类型的引用。一个类如果继承了抽象类或者实现了某个接口，那么它就必要对抽象方法全部进行实现，否则这个类仍然要被定义成抽象类。接口比抽象类更加抽象，因为接口中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器，并且其中的方法全是抽象方法。抽象类中的成员可以有private,public,默认，protected。在jdk1.8之前，接口中只能定义抽象方法，不能定义实现方法的，但在1.8之后，接口中可以定义实现，子类可以重写，也可以不重写，比之前接口的灵活性更大。

##### 6.Java中会存在内存泄漏吗
		理论上讲Java因为有垃圾回收机制不会存在内存泄漏。但是在实际开发中，可能会存在无用但可达到对象，这些对象不能被GC回收，因为也会导致内存泄漏的发生。比如hibernate的Session（一级缓存）中的对象属于持久态，GC是不会回收这些对象的，然而这些对象中可能存在一些无用的垃圾，如果不及时close或flush，一级缓存可能导致内存泄漏。

##### 7.GC是什么，为什么要有GC
		GC是垃圾回收器，Java提供的GC功能可以自动检测对象是否超过作用域从而到达自动回收内存的目的，要请求垃圾收集，可以调用System.get()或Runtime.getRuntime().gc，但JVM可以屏蔽掉显示的垃圾回收调用。
		垃圾回收可以有效的防止内存泄漏，有效的使用可以使用的内存。垃圾回收器通常作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死忙的和长时间没有使用的对象进行清除和回收。
		垃圾回收机制有很多种，包括分代复制垃圾回收，标记垃圾回收，增量垃圾回收等方式。

##### 8.final,finally,finalize的区别
		final:修饰符，有三种用法
			1.修饰类:表示该类不能被继承
			2.修饰方法:表示方法不能被重写
			3.修饰变量:表示变量赋值以后不能被修改
		finally:通常用在try...catch...的后面构造总是执行代码块,这就意味着无论程序是正常运行还是发生异常,这里的代码只要JVM不关闭就能知晓
		finalize:Object类中定义的方法,Java中允许使用finalize()在垃圾收集器将对象从内存中清除出去之前做必要的清理工作.这个方法是由垃圾收集器在销毁对象时调用的,通过重写finalize()方法可以整理系统资源或者执行其他清理工作.

##### 9.List,Set,Map是否继承自Collection接口
		List,Set是,Map不是.Map是键值对映射容器,与List和Set有明显的区别,Set存储的零散的元素并且不允许有重复元素,List是线性结构的容器,适用于按数值索引访问元素的情形

##### 10.ArrayList,Vector,LinkedList的存储性能和特性
		ArrayList和Vector都实现了List接口，底层都是基于数组来存储元素。ArrayList和Vector绝大部分方法的实现都是相同的，只是Vector的方法增加了synchronized修饰。
		LinkedList使用双向链表实现存储，按照序号索引可以选择向前或者向后遍历这种链表式存储方法比用数组的存储方式内存的利用率更高，所以插入速度更快。
		ArrayList和LinkedList线程都是不安全的。
##### 11.List，Map,Set三个接口存取元素时，各有什么特点
		List以特定的索引来存取元素，可以有重复元素。Set不能存放重复元素，Map是键值对映射容器，映射关系可以是一对一或者多对一。Set和Map容器都有基于哈希存储和排序树的两种实现版本

##### 12.Thread类的sleep()方法和对象wait()方法都可以让线程暂停执行，他们有什么区别？
		sleep()方法是线程类的静态方法。调用此方法会让当前线程暂停执行指定时间,将执行机会让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复，即现场会回到就绪状态。
		wait()是Object类的方法，调用对象的Object类方法会导致当前线程放弃对象的锁，进入对象的等待池，只有调用notify()或者notifyAll()方法时才会唤醒等待池中的方法进入等锁池，如果线程重新获得对象的锁就可以进入就绪状态。

##### 13.线程的sleep()方法和yiled()方法有什么区别
		1.sleep()方法给其他运行机会时不考虑优先级，因此会给低优先级的线程以运行的机会;yiled()方法只会给相同优先级或更高优先级的线程运行的机会;
		2.线程执行sleep()方法后转入阻塞(blocked)状态，执行yiled()方法后进入就绪状态;
		3.sleep()方法声明抛出 InterrupdtedException，yiled()方法没有声明任何异常
		4.sleep()方法比yiled()方法具有更好的可移植性。

##### 14.当一个线程进入对象的synchronized的方法A之后，其他线程能否可以进入此对象的synchronized方法B？
		不能。
		其他线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的esynchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法就说明对象锁已经被取走，那么视图进入B方法的线程只能在等锁池中等待对象的锁

##### 15.线程同步以及线程调度相关的方法
		wait():使一个线程处于等待(阻塞)状态，并且释放所持有的对象的锁
		sleep():使一个正在运行的线程处于休眠状态，是一个静态方法。调用此方法要处理InterrupytedException异常
		notify():唤醒一个处于等待的线程，但是在调用此方法的时候。并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关
		notifyAll():唤醒所有处于等待状态的线程，该方法斌哥不是讲对象的锁给所有线程，而是让他们竞争，只有获得锁定线程才能进入就绪状态
		lock():显式的锁机制，增强了灵活性以及对线程的协调，Lock接口中定义了加锁和解锁的方法，同时还提供了newCondition()方法来阐述用于线程之间通信的Condition对象

##### 16.实现多线程的方式
		继承Thread类，实现Runnable接口。这两种方式都要通过重写run()方法来定义线程的行为；
		使用Executor,Callable,Future实现有返回结果的多线程

##### 17.synchronized关键字的作用
		可以将对象或者方法标记为同步，以实现对象和方法的互斥访问。可以用synchronized(对象){...}定义同步代码块，或者在声明方法时作为方法的修饰符。

##### 18.synchronized和lock的异同
		Lock能完成synchronized所实现的所有功能;
		不同点:Lock有比synchronized更精确的现场语义和更好的性能，而且不强制性地要求一定要获得锁，synchronized会自动释放锁，而Lock要求手动释放。并且最好在finally块中释放。

##### 19.Java中如何实现序列化，有什么意义
		序列化就是一种用来处理对象流的机制，所谓对象流就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可以将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题。

##### 20.char类型能不能存储汉字？
        char类型是可以存储汉字的，unicode编码是可以存储汉字的，但是如果某个特殊的汉字没有包含在udicode编码中，char类型就不可以存储这个汉字

